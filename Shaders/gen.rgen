#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

struct HitPayload
{
    vec3 contribution;
    vec3 position;
    vec3 normal;
    bool done;
};

layout(location = 0) rayPayloadEXT HitPayload hitPayload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;
layout(set = 0, binding = 2) uniform UniformData {
	mat4 view_inverse;
	mat4 proj_inverse;
	uint frame;
} uniformData;

// Functions

const highp float M_PI = 3.14159265358979323846;

uint pcg(inout uint state)
{
    uint prev = state * 747796405u + 2891336453u;
    uint word = ((prev >> ((prev >> 28u) + 4u)) ^ prev) * 277803737u;
    state     = prev;
    return (word >> 22u) ^ word;
}

uvec2 pcg2d(uvec2 v)
{
    v = v * 1664525u + 1013904223u;

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v >> 16u);

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v >> 16u);

    return v;
}

float rand(inout uint seed)
{
    uint val = pcg(seed);
    return (float(val) * (1.0 / float(0xffffffffu)));
}

void main()
{
	uint  rayFlags = gl_RayFlagsOpaqueEXT;
	float tMin     = 0.001;
	float tMax     = 10000.0;
	uint maxDepth = 3;
	uint maxSamples = 128;
	vec3 summedPixelColor = vec3(0.0);
	
	for(uint sampleCount = 0; sampleCount < maxSamples; sampleCount++){
		uvec2 s = pcg2d(ivec2(gl_LaunchIDEXT.xy) * (sampleCount + uniformData.frame));
        uint seed = s.x + s.y;
		
		const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(rand(seed), rand(seed));
		const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
		vec2       d           = inUV * 2.0 - 1.0;
		
		vec4 origin    = uniformData.view_inverse * vec4(0, 0, 0, 1);
		vec4 target    = uniformData.proj_inverse * vec4(d.x, d.y, 1, 1);
		vec4 direction = uniformData.view_inverse * vec4(normalize(target.xyz), 0);
		
		hitPayload.contribution = vec3(1.0);
        hitPayload.done = false;
		
		for(uint depth = 0; depth < maxDepth; depth++){
			traceRayEXT(
				topLevelAS,     // acceleration structure
				rayFlags,       // rayFlags
				0xFF,           // cullMask
				0,              // sbtRecordOffset
				0,              // sbtRecordStride
				0,              // missIndex
				origin.xyz,     // ray origin
				tMin,           // ray min range
				direction.xyz,  // ray direction
				tMax,           // ray max range
				0               // hitPayload (location = 0)
			);
			if(hitPayload.done){
				break;
			}
			
			// random diffuse bounce direction
			const float theta = 6.2831853 * rand(seed);  // Random in [0, 2pi]
			const float u     = 2.0 * rand(seed) - 1.0;  // Random in [-1, 1]
			const float r     = sqrt(1.0 - u * u);
			
			direction = vec4(hitPayload.normal + vec3(r * cos(theta), r * sin(theta), u), 0);
			direction = normalize(direction);
			
            origin = vec4(hitPayload.position + 0.0001 * hitPayload.normal, 1.0);
		}
		
		summedPixelColor += hitPayload.contribution / maxSamples;
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(summedPixelColor, 0));
}